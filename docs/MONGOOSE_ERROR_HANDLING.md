# Enterprise-Grade Error Handling in MongoosePlugin

## Overview

As of KarinJS v0.5+, `@karin-js/mongoose` provides **automatic, enterprise-grade error handling** out of the box. You no longer need to manually create and register Mongoose exception filters in your application code.

## The Problem (Before)

In early versions (v0.x), developers had to:

1. **Understand Mongoose internals**: Know about `ValidationError`, `CastError`, `MongoServerError`, etc.
2. **Create custom filters**: Write boilerplate code to handle these errors
3. **Register manually**: Remember to add filters to `globalFilters`

```typescript
// ‚ùå OLD WAY (v0.x): Manual error handling required
import { MongooseExceptionFilter } from "./filters/mongoose.filter";

const app = await KarinFactory.create(adapter, {
  plugins: [
    new MongoosePlugin({ uri: "..." }),
  ],
  globalFilters: [
    new MongooseExceptionFilter(),  // Developer must create and register this
  ],
});
```

**Problems:**
- ‚ùå Boilerplate code in every project
- ‚ùå Inconsistent error responses across projects
- ‚ùå Developers need to know Mongoose internals
- ‚ùå Easy to forget to register the filter

## The Solution (Now)

`MongoosePlugin` now **automatically registers** a built-in `MongooseExceptionFilter` that handles all Mongoose errors and converts them to proper HTTP responses.

```typescript
// ‚úÖ NEW WAY (v0.5+): Automatic error handling
const app = await KarinFactory.create(adapter, {
  plugins: [
    new MongoosePlugin({
      uri: () => config.get("MONGO_URI"),
      options: () => ({
        dbName: config.get("DB_NAME"),
      }),
    }),
    // ‚úÖ That's it! MongooseExceptionFilter is auto-registered
  ],
});
```

**Benefits:**
- ‚úÖ Zero boilerplate
- ‚úÖ Consistent error responses
- ‚úÖ Works out of the box
- ‚úÖ Enterprise-grade by default
## What Errors Are Handled?

The built-in `MongooseExceptionFilter` handles:

### 1. **ValidationError** ‚Üí `400 Bad Request`

When Mongoose schema validation fails:

```typescript
// Schema
@Schema()
class User {
  @Prop({ required: true, minlength: 3 })
  name: string;

  @Prop({ required: true, match: /^[\w-\.]+@([\w-]+\.)+[\w-]{2,4}$/ })
  email: string;
}

// Request with invalid data
POST /users
{
  "name": "Jo",  // Too short
  "email": "invalid"  // Invalid format
}

// Response (auto-generated by MongooseExceptionFilter)
{
  "statusCode": 400,
  "timestamp": "2025-11-29T18:00:00.000Z",
  "path": "/users",
  "error": "Validation Error",
  "message": "The provided data is invalid",
  "details": [
    {
      "field": "name",
      "message": "Path `name` (`Jo`) is shorter than the minimum allowed length (3).",
      "value": "Jo"
    },
    {
      "field": "email",
      "message": "Path `email` is invalid (invalid).",
      "value": "invalid"
    }
  ]
}
```

### 2. **CastError** ‚Üí `400 Bad Request`

When an invalid ID format is provided:

```typescript
// Request with invalid ObjectId
GET /users/invalid-id-format

// Response (auto-generated)
{
  "statusCode": 400,
  "timestamp": "2025-11-29T18:00:00.000Z",
  "path": "/users/invalid-id-format",
  "error": "Invalid ID",
  "message": "The value 'invalid-id-format' is not a valid ID for field '_id'"
}
```

### 3. **MongoServerError (Duplicate Key)** ‚Üí `409 Conflict`

When trying to insert a duplicate unique field:

```typescript
// Schema with unique constraint
@Schema()
class User {
  @Prop({ unique: true })
  email: string;
}

// Request with duplicate email
POST /users
{
  "email": "existing@example.com"
}

// Response (auto-generated)
{
  "statusCode": 409,
  "timestamp": "2025-11-29T18:00:00.000Z",
  "path": "/users",
  "error": "Duplicate Entry",
  "message": "A record with this email already exists",
  "field": "email"
}
```

### 4. **Other Database Errors** ‚Üí `500 Internal Server Error`

For unexpected database errors:

```typescript
{
  "statusCode": 500,
  "timestamp": "2025-11-29T18:00:00.000Z",
  "path": "/users",
  "error": "Database Error",
  "message": "An error occurred while processing your request"
}
```

## Configuration Options

### Default Behavior (Recommended)

By default, `MongoosePlugin` automatically registers the exception filter:

```typescript
new MongoosePlugin({
  uri: () => config.get("MONGO_URI"),
  // autoRegisterExceptionFilter: true (default)
})
```

### Opt-Out (Advanced)

If you want to provide your own custom error handling:

```typescript
new MongoosePlugin({
  uri: () => config.get("MONGO_URI"),
  autoRegisterExceptionFilter: false,  // Disable auto-registration
})
```

Then register your own custom filter:

```typescript
const app = await KarinFactory.create(adapter, {
  plugins: [
    new MongoosePlugin({
      uri: "...",
      autoRegisterExceptionFilter: false,
    }),
  ],
  globalFilters: [
    new MyCustomMongooseFilter(),  // Your custom implementation
  ],
});
```

## Using the Filter Directly

If you need to use the filter in a different context, you can import it:

```typescript
import { MongooseExceptionFilter } from "@karin-js/mongoose";

// Use it in a specific controller
@Controller("/users")
@UseFilters(MongooseExceptionFilter)
export class UsersController {
  // ...
}
```

## Migration Guide

### From v0.x to v0.5+

#### Before (v0.x)

```typescript
// 1. Create custom filter (in your project)
// src/filters/mongoose.filter.ts
import { Catch, ExceptionFilter } from "@karin-js/core";
import { Error as MongooseError } from "mongoose";

@Catch(MongooseError.ValidationError, MongooseError.CastError)
export class MongooseExceptionFilter implements ExceptionFilter {
  catch(exception: any, host: ArgumentsHost) {
    // ... lots of boilerplate code
  }
}

// 2. Register manually in main.ts
import { MongooseExceptionFilter } from "./filters/mongoose.filter";

const app = await KarinFactory.create(adapter, {
  plugins: [
    new MongoosePlugin({ uri: "..." }),
  ],
  globalFilters: [
    new MongooseExceptionFilter(),  // Manual registration
  ],
});
```

#### After (v0.5+)

```typescript
// ‚úÖ Just use MongoosePlugin - that's it!
const app = await KarinFactory.create(adapter, {
  plugins: [
    new MongoosePlugin({
      uri: () => config.get("MONGO_URI"),
    }),
    // MongooseExceptionFilter is auto-registered
  ],
});

// üóëÔ∏è Delete src/filters/mongoose.filter.ts - no longer needed!
```

**Steps:**
1. Remove your custom `MongooseExceptionFilter` file
2. Remove the import from `main.ts`
3. Remove it from `globalFilters` array
4. Done! The plugin handles it automatically

## Comparison with Other Frameworks

### NestJS

```typescript
// NestJS: Manual filter creation and registration required
import { Catch, ExceptionFilter } from '@nestjs/common';
import { MongoError } from 'mongodb';

@Catch(MongoError)
export class MongoExceptionFilter implements ExceptionFilter {
  catch(exception: MongoError, host: ArgumentsHost) {
    // Manual implementation required
  }
}

// Must register in main.ts
app.useGlobalFilters(new MongoExceptionFilter());
```

### KarinJS

```typescript
// KarinJS: Zero configuration, works out of the box
new MongoosePlugin({ uri: "..." })
// ‚úÖ Done! Error handling included
```

## Best Practices

### 1. Use Default Behavior

Unless you have very specific requirements, use the default auto-registration:

```typescript
// ‚úÖ GOOD: Let the plugin handle it
new MongoosePlugin({ uri: "..." })

// ‚ùå AVOID: Don't disable unless necessary
new MongoosePlugin({
  uri: "...",
  autoRegisterExceptionFilter: false,
})
```

### 2. Customize Error Messages (If Needed)

If you need custom error messages, extend the built-in filter:

```typescript
import { MongooseExceptionFilter } from "@karin-js/mongoose";

export class CustomMongooseFilter extends MongooseExceptionFilter {
  catch(exception: any, host: ArgumentsHost) {
    // Add custom logic (e.g., i18n, logging)
    const response = super.catch(exception, host);
    
    // Customize response
    return response;
  }
}

// Use custom filter
new MongoosePlugin({
  uri: "...",
  autoRegisterExceptionFilter: false,
})

// In globalFilters
globalFilters: [new CustomMongooseFilter()]
```

### 3. Log Errors for Monitoring

The built-in filter automatically logs errors:

```
ü¶ä ‚îÇ 18:00:12 ‚îÇ ERR  ‚îÇ MongooseExceptionFilter   Mongoose Error: Validation failed: email: Path `email` is invalid
```

Integrate with your monitoring system (Sentry, DataDog, etc.):

```typescript
import * as Sentry from "@sentry/node";

export class SentryMongooseFilter extends MongooseExceptionFilter {
  catch(exception: any, host: ArgumentsHost) {
    // Report to Sentry
    Sentry.captureException(exception);
    
    // Return standard response
    return super.catch(exception, host);
  }
}
```

## Technical Details

### Filter Order

The `MongooseExceptionFilter` is registered during the `install()` phase of the plugin lifecycle:

```typescript
install(app: KarinApplication) {
  // 1. Register exception filter first
  if (this.config.autoRegisterExceptionFilter !== false) {
    app.useGlobalFilters(new MongooseExceptionFilter());
  }
  
  // 2. Then register models, etc.
  this.registerModels();
}
```

This ensures the filter is available before any routes are registered.

### Error Catching

The filter uses the `@Catch()` decorator to specify which errors it handles:

```typescript
@Catch(MongooseError.ValidationError, MongooseError.CastError)
export class MongooseExceptionFilter implements ExceptionFilter {
  // ...
}
```

It also handles `MongoServerError` (e.g., duplicate keys) by checking the error name at runtime.

## Troubleshooting

### Filter not catching errors

**Cause:** You disabled auto-registration but forgot to register your own filter.

**Solution:** Either enable auto-registration or register a custom filter:

```typescript
// Option 1: Enable auto-registration (recommended)
new MongoosePlugin({ uri: "..." })

// Option 2: Register custom filter
new MongoosePlugin({
  uri: "...",
  autoRegisterExceptionFilter: false,
})
// In globalFilters:
globalFilters: [new MyCustomFilter()]
```

### Custom filter not working

**Cause:** Both auto-registration and custom filter are active, causing conflicts.

**Solution:** Disable auto-registration when using a custom filter:

```typescript
new MongoosePlugin({
  uri: "...",
  autoRegisterExceptionFilter: false,  // ‚úÖ Disable built-in
})
```

### Errors not formatted correctly

**Cause:** Another global filter is catching the error first.

**Solution:** Check filter order. Specific filters should come before generic ones:

```typescript
globalFilters: [
  new MongooseExceptionFilter(),  // Specific (Mongoose errors)
  new HttpErrorFilter(),           // Generic (all HTTP errors)
]
```

## Summary

| Feature | v0.x (Manual) | v0.5+ (Automatic) |
|---------|---------------|-------------------|
| Error handling | ‚ùå Manual | ‚úÖ Automatic |
| Boilerplate code | ‚ùå Required | ‚úÖ Zero |
| Consistency | ‚ö†Ô∏è Varies by project | ‚úÖ Standardized |
| Developer experience | ‚ùå Complex | ‚úÖ Simple |
| Enterprise-ready | ‚ö†Ô∏è If implemented | ‚úÖ Out of the box |

**Bottom line:** MongoosePlugin now provides enterprise-grade error handling automatically. You don't need to think about it - it just works! üéâ
